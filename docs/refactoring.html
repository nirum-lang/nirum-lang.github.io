<!DOCTYPE html>
<html><head><meta charset="utf-8">
<title>Backward Compatible Refactoring &mdash; Nirum</title>
<meta name="generator" content="Nirum 0.5.0">
<meta name="author" content="Nirum team">
<link rel="stylesheet" href="../style.css">
</head>
<body>
<nav><a class="index" href="../index.html">Nirum</a>
<ul class="manuals toc"><li><a href="../docs/annotation.html">Annotations</a>
</li>
<li><a href="../docs/package.html">Package</a>
</li>
<li class="selected"><a href="../docs/refactoring.html"><strong>Backward Compatible Refactoring</strong>
</a>
</li>
<li><a href="../docs/serialization.html">Serialization format</a>
</li>
<li><a href="../docs/transport.html">Transport</a>
</li>
<li><a href="../docs/tutorial.html">Step-by-step tutorial</a>
</li>
<li><a href="../docs/target/docs.html">Docs target</a>
</li>
<li><a href="../docs/target/python.html">Python target</a>
</li>
<li><a href="../CHANGES.html">Nirum changelog</a>
</li>
<li><a href="../CONTRIBUTING.html">Contirubtion guide</a>
</li>
</ul>
<ul class="modules toc"><li><a href="../core/index.html"><code>core</code></code>
&mdash; Built-in types</a>
</li>
</ul>
</nav>
<article><h1>Backward Compatible Refactoring</h1>
<p>Nirum is designed to marshal well-typed data for networking.  That means types
defined in Nirum IDL are shared with other programs over the network.
“Other programs” mean they usually aren’t deployed together.
Even if some of your types defined in Nirum IDL was evolved and the changes
were deployed to some programs that use them, some other programs still works
as the types were not changed yet until the changes are deployed to all involved
programs together.</p>
<p>To help types defined in Nirum IDL to be possible to be evolved with backward
compatibility, Nirum types provide several properties.</p>
<h2>Behind names for old names</h2>
<p>The most of identifiers in Nirum IDL have a facial name and a behind name.
By default, these two names are the same.  For example, the following two
declarations are equivalent:</p>
<pre><code>record money (decimal amount, currency currency);

record money/money (decimal amount/amount, currency currency/currency);
</code></pre>
<p>A facial name is a descriptive identifier for humans.  Object codes generated
by Nirum compiler have identifiers named after facial names.</p>
<p>On the other hand, a behind name is an arbitrary identifier for programs.
JSON payloads produced by serializers (that are generated by Nirum compiler)
have identifiers named after behind names.</p>
<p>The following declaration shows a record and its fields having behind names
different from their facial names:</p>
<pre><code>record point2d/point (
    float64 left/x,
    float64 top/y,
);
</code></pre>
<p>The above IDL becomes to the following Python code for example (although it
approximates details):</p>
<pre><code class="language-python">class Point2d:
    def __init__(self, left: float, top: float) -> None:
        self.left = left
        self.top = top
</code></pre>
<p>For example, <code>Point2d(left=1.23, top=4.56)</code> value is serialized to the following
JSON payload:</p>
<pre><code class="language-json">{
    "_type": "point",
    "x": 1.23,
    "y": 4.56
}
</code></pre>
<p>Note that the above JSON payload names its type and fields after the behind
names like <code>point</code>, <code>x</code> and <code>y</code>, whereas the above Python code names its class
and attributes after the facial names like <code>Point2d</code>, <code>left</code> and <code>top</code>.</p>
<p>Separating a facial name from a behind name is useful when to rename
a misleading name (or an outdated name) to a more clear name (or an up-to-date
name).</p>
<h2>Type alias</h2>
<p>Type aliases are not distinct.  While it’s being compiled all type aliases are
simply replaced by types they refer to.  So every type alias doesn’t break
backward compatibility.  Feel free to define type aliases!</p>
<h2>Unboxed type</h2>
<p>Unboxed types can be used for semi-refactoring: you can make people to say
things by a specific name in program codes, while leave programs to communicate
each other in the way they’ve done.</p>
<p>The key difference between unboxed types and single-field records is that
unboxed types don’t make additional structure on its inner type whereas
records always adds object structure to wrap its fields.</p>
<p>For example, the following two types are seemingly equivalent to program codes
and programmers:</p>
<pre><code>unboxed meter (bigint);

record meter (bigint value);
</code></pre>
<p>However, they make different JSON payloads:</p>
<pre><code class="language-json">"123"
</code></pre>
<pre><code class="language-json">{"_type": "meter", "value": "123"}
</code></pre>
<p>This means unboxed types are indistinguishable from their inner types in JSON
payloads, while in program codes they are distinct individual types.</p>
<p>Suppose we’ve represented distance <code>bigint</code> with assuming 1 means 1 meter.</p>
<pre><code>service map-service (
    bigint find-distance(coord a, coord b),
);
</code></pre>
<p>As such scale/unit assumptions are error-prone, we want to encode them
as distinct type without breaking backward compatibility.  It’s the when
unboxed types are useful:</p>
<pre><code>unboxed meter (bigint);

service map-service (
    meter find-distance (coord a, coord b),
);
</code></pre>
<p>The above change doesn’t affect to JSON payloads the <code>find-distance</code> method
returns, but in program codes we become able to deal with distance using <code>meter</code>
type rather than primitive <code>bigint</code> type.</p>
<h2>Removing a field</h2>
<p>Any fields in payload that are unlisted in an interface definition are ignored
by a deserializer.  If you are going to remove an existing field you should
deploy the newer version to a payload consumer first, and then a payload
provider last.</p>
<h2>Interchangeability of enum type and <code>text</code></h2>
<p>Enum types are represented as JSON strings as like <code>text</code>.  If a field had been
represented as <code>text</code> but there are only the limited number of values, it’s
okay to be refactored to <code>enum</code> type.</p>
<p>Suppose the following record had represented <code>gender</code> as freeform <code>text</code>:</p>
<pre><code>record person (
    text name,
    text gender,  // represented as texts e.g. "male", "female"
);
</code></pre>
<p>Although it had become <code>text</code> due to a design mistake, we still have a chance
to make up for it.  Because there are only few cases:</p>
<pre><code class="language-json">{"_type": "person", "name": "Jane Doe", "gender": "male"}
</code></pre>
<pre><code class="language-json">{"_type": "person", "name": "John Doe", "gender": "female"}
</code></pre>
<p>The following change is still mostly compatible with the previous revision:</p>
<pre><code>enum gender = male | female | unknown;

record person (
    text name,
    gender gender,
);
</code></pre>
<h2>Making field optional</h2>
<p>An option type modifier (<code>?</code>) indicates a field can be <code>null</code> in JSON payloads.
Fortunately making a field which had disallowed <code>null</code> to allow <code>null</code> does not
require any structural changes of JSON payloads.  In other words, every valid
JSON payload that a field disallowing <code>null</code> accepts is also accepted by
the same field but of <code>null</code> allowance.</p>
<p>On the other hand, when it comes to reversed, optional fields cannot be
required without any compatible breakage.  Also, if two programs communicate
each other, one deserializing and receiving payloads has to be deployed before
other one serializing and sending payloads.</p>
<h2>Interchangeability of set and list</h2>
<p>A set contains zero or more unique values of the same type, without order.</p>
<p>A list contains zero or more values of the same type, in an order, and allows
duplicated values.</p>
<p>However, both set and list types are serialized to equally an array in JSON
payloads.  So a set field and a list type are interchangeable each other
unless their element types are different.</p>
<p>(More accurately, a set and a list still might be interchangeable even if
their element types are different since two element types may be
interchangeable.  For example, <code>{[a]}</code> and <code>[{a}]</code> are interchangeable since
<code>[a]</code> and <code>{a}</code> are interchangeable, and <code>a</code> and <code>a</code> are interchangeable again.)</p>
<p>When a JSON array serialized from a set field is deserialized to a list,
its order becomes arbitrary.  A program accepting payloads have to deal with
its lack of order if necessary.</p>
<p>When a JSON array serialized from a list field is deserialized to a set,
the same values shown more than once are collapsed to unique values.
Also, its order is not preserved.</p>
<h2>Interchangeability of union type and record type</h2>
<p>Sometimes we need to evolve an existing record type to be extended.</p>
<p>But when we change a record type to a union type, it breaks backward
compatibility.  Suppose we have a record type named <code>name</code> that looks like:</p>
<pre><code class="language-nirum">record name (text fullname);
</code></pre>
<p>An example of JSON serialized one would look like:</p>
<pre><code class="language-json">{
    "_type": "name",
    "fullname": "John Doe"
}
</code></pre>
<p>What if we need to be more sensible to culture-specific names?  Now we decide
to change it to a union:</p>
<pre><code class="language-nirum">union name
    = wastern-name (text first-name, text? middle-name, text last-name)
    | east-asian-name (text family-name, text given-name)
    | culture-agnostice-name (text fullname)
    ;
</code></pre>
<p>Since union types requires <code>&quot;_tag&quot;</code> field besides <code>&quot;_type&quot;</code> field when
they are deserialized, data sent from the older programs becomes to break
compatibility.</p>
<p>In order to make union types possible to deserialize existing record data
(which lacks <code>&quot;_tag&quot;</code> field), we need to choose <code>default</code> tag for data lacking
<code>&quot;_tag&quot;</code> field:</p>
<pre><code class="language-nirum">union name
    = wastern-name (text first-name, text? middle-name, text last-name)
    | east-asian-name (text family-name, text given-name)
    | default culture-agnostice-name (text fullname)
    ;
</code></pre>
<p>With a <code>default</code> tag, union types become possible to deserialize data lacking
<code>&quot;_tag&quot;</code> field, and they are treated as an instance of the <code>default</code> tag.
For example, where we have a payload data like:</p>
<pre><code class="language-json">{
    "_type": "name",
    "fullname": "John Doe"
}
</code></pre>
<p>It’s treated as equivalent to the following one:</p>
<pre><code class="language-json">{
    "_type": "name",
    "_tag": "culture_agnostic_name",
    "fullname": "John Doe"
}
</code></pre>
</article>

<div class="github"><a href="https://github.com/nirum-lang/nirum" class="github-corner" aria-label="View source on GitHub"><svg width="80" height="80" viewBox="0 0 250 250" style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a></div>
</body>
</html>
